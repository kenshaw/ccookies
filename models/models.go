// Package models contains generated code for schema 'Cookies'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"io"
	"time"
)

var (
	// logf is used by generated code to log SQL queries.
	logf = func(string, ...interface{}) {}
	// errf is used by generated code to log SQL errors.
	errf = func(string, ...interface{}) {}
)

// logerror logs the error and returns it.
func logerror(err error) error {
	errf("ERROR: %v", err)
	return err
}

// Logf logs a message using the package logger.
func Logf(s string, v ...interface{}) {
	logf(s, v...)
}

// SetLogger sets the package logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetLogger(logger interface{}) {
	logf = convLogger(logger)
}

// Errorf logs an error message using the package error logger.
func Errorf(s string, v ...interface{}) {
	errf(s, v...)
}

// SetErrorLogger sets the package error logger. Valid logger types:
//
//     io.Writer
//     func(string, ...interface{}) (int, error) // fmt.Printf
//     func(string, ...interface{}) // log.Printf
//
func SetErrorLogger(logger interface{}) {
	errf = convLogger(logger)
}

// convLogger converts logger to the standard logger interface.
func convLogger(logger interface{}) func(string, ...interface{}) {
	switch z := logger.(type) {
	case io.Writer:
		return func(s string, v ...interface{}) {
			fmt.Fprintf(z, s, v...)
		}
	case func(string, ...interface{}) (int, error): // fmt.Printf
		return func(s string, v ...interface{}) {
			_, _ = z(s, v...)
		}
	case func(string, ...interface{}): // log.Printf
		return z
	}
	panic(fmt.Sprintf("unsupported logger type %T", logger))
}

// DB is the common interface for database operations that can be used with
// types from schema 'Cookies'.
//
// This works with both database/sql.DB and database/sql.Tx.
type DB interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

// Error is an error.
type Error string

// Error satisfies the error interface.
func (err Error) Error() string {
	return string(err)
}

// Error values.
const (
	// ErrAlreadyExists is the already exists error.
	ErrAlreadyExists Error = "already exists"
	// ErrDoesNotExist is the does not exist error.
	ErrDoesNotExist Error = "does not exist"
	// ErrMarkedForDeletion is the marked for deletion error.
	ErrMarkedForDeletion Error = "marked for deletion"
)

// ErrInsertFailed is the insert failed error.
type ErrInsertFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrInsertFailed) Error() string {
	return fmt.Sprintf("insert failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrInsertFailed) Unwrap() error {
	return err.Err
}

// ErrUpdateFailed is the update failed error.
type ErrUpdateFailed struct {
	Err error
}

// Error satisfies the error interface.
func (err *ErrUpdateFailed) Error() string {
	return fmt.Sprintf("update failed: %v", err.Err)
}

// Unwrap satisfies the unwrap interface.
func (err *ErrUpdateFailed) Unwrap() error {
	return err.Err
}

// ErrInvalidTime is the invalid Time error.
type ErrInvalidTime string

// Error satisfies the error interface.
func (err ErrInvalidTime) Error() string {
	return fmt.Sprintf("invalid Time (%s)", string(err))
}

// Time is a SQLite3 Time that scans for the various timestamps values used by
// SQLite3 database drivers to store time.Time values.
type Time struct {
	time time.Time
}

// NewTime creates a time.
func NewTime(t time.Time) Time {
	return Time{time: t}
}

// String satisfies the fmt.Stringer interface.
func (t Time) String() string {
	return t.time.String()
}

// Format formats the time.
func (t Time) Format(layout string) string {
	return t.time.Format(layout)
}

// Time returns a time.Time.
func (t Time) Time() time.Time {
	return t.time
}

// Value satisfies the sql/driver.Valuer interface.
func (t Time) Value() (driver.Value, error) {
	return t.time, nil
}

// Scan satisfies the sql.Scanner interface.
func (t *Time) Scan(v interface{}) error {
	switch x := v.(type) {
	case time.Time:
		t.time = x
		return nil
	case []byte:
		return t.Parse(string(x))
	case string:
		return t.Parse(x)
	}
	return ErrInvalidTime(fmt.Sprintf("%T", v))
}

// Parse attempts to Parse string s to t.
func (t *Time) Parse(s string) error {
	if s == "" {
		return nil
	}
	for _, f := range TimestampFormats {
		if z, err := time.Parse(f, s); err == nil {
			t.time = z
			return nil
		}
	}
	return ErrInvalidTime(s)
}

// TimestampFormats are the timestamp formats used by SQLite3 database drivers
// to store a time.Time in SQLite3.
//
// The first format in the slice will be used when saving time values into the
// database.  When parsing a string from a timestamp or datetime column, the
// formats are tried in order.
var TimestampFormats = []string{
	// By default, use timestamps with the timezone they have. When parsed,
	// they will be returned with the same timezone.
	"2006-01-02 15:04:05.999999999-07:00",
	"2006-01-02T15:04:05.999999999-07:00",
	"2006-01-02 15:04:05.999999999",
	"2006-01-02T15:04:05.999999999",
	"2006-01-02 15:04:05",
	"2006-01-02T15:04:05",
	"2006-01-02 15:04",
	"2006-01-02T15:04",
	"2006-01-02",
}

// Cookie is a browser cookie.
type Cookie struct {
	HostKey        string         `json:"host_key"`        // host_key
	Name           string         `json:"name"`            // name
	EncryptedValue EncryptedValue `json:"encrypted_value"` // encrypted_value
	Path           string         `json:"path"`            // path
	ExpiresUTC     ExpiresUTC     `json:"expires_utc"`     // expires_utc
	IsSecure       bool           `json:"is_secure"`       // is_secure
	IsHTTPOnly     bool           `json:"is_http_only"`    // is_http_only
}

// Cookies retrieves cookies.
func Cookies(ctx context.Context, db DB, host string) ([]*Cookie, error) {
	// query
	sqlstr := `/* ` + host + ` */ ` +
		`SELECT ` +
		`host_key, ` +
		`name, ` +
		`encrypted_value, ` +
		`path, ` +
		`expires_utc, ` +
		`is_secure, ` +
		`is_httponly ` +
		`FROM cookies`
	// run
	logf(sqlstr)
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Cookie
	for rows.Next() {
		var c Cookie
		// scan
		if err := rows.Scan(&c.HostKey, &c.Name, &c.EncryptedValue, &c.Path, &c.ExpiresUTC, &c.IsSecure, &c.IsHTTPOnly); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// CookiesByHost retrieves cookies by host.
func CookiesByHost(ctx context.Context, db DB, host string) ([]*Cookie, error) {
	// query
	const sqlstr = `SELECT ` +
		`host_key, ` +
		`name, ` +
		`encrypted_value, ` +
		`path, ` +
		`expires_utc, ` +
		`is_secure, ` +
		`is_httponly ` +
		`FROM cookies ` +
		`WHERE host_key LIKE $1`
	// run
	logf(sqlstr, host)
	rows, err := db.QueryContext(ctx, sqlstr, host)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Cookie
	for rows.Next() {
		var c Cookie
		// scan
		if err := rows.Scan(&c.HostKey, &c.Name, &c.EncryptedValue, &c.Path, &c.ExpiresUTC, &c.IsSecure, &c.IsHTTPOnly); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
